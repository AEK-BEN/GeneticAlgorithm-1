<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GeneticAlgorithm: src/examples/KnapsackDemo.py Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GeneticAlgorithm
   &#160;<span id="projectnumber">0.5 (beta)</span>
   </div>
   <div id="projectbrief">A python framework for rapid GA prototyping</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('KnapsackDemo_8py.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">src/examples/KnapsackDemo.py</div>  </div>
</div><!--header-->
<div class="contents">
<a href="KnapsackDemo_8py.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a><a class="code" href="namespaceKnapsackDemo.html">00001</a> <span class="keyword">import</span> math
<a name="l00002"></a>00002 <span class="keyword">from</span> GeneticAlgorithm <span class="keyword">import</span> *
<a name="l00003"></a>00003 <span class="comment">## @page KnapsackPage Solving the Knapsack problem</span>
<a name="l00004"></a>00004 <span class="comment">#  </span>
<a name="l00005"></a>00005 <span class="comment">#  @section KnapsackIntroduction Introduction</span>
<a name="l00006"></a>00006 <span class="comment">#  This page describes how to use the GeneticAlgorithm framework to solve the knapsack problem.</span>
<a name="l00007"></a>00007 <span class="comment">#  The knapsack0-1 problem can be defined as follows:</span>
<a name="l00008"></a>00008 <span class="comment">#   \f{eqnarray*}{</span>
<a name="l00009"></a>00009 <span class="comment">#        \max \limits_{\textbf{s}} z =&amp; \textbf{c}^{\textrm{T}}\textbf{s} \\</span>
<a name="l00010"></a>00010 <span class="comment">#        \textrm{subject to} &amp; \\</span>
<a name="l00011"></a>00011 <span class="comment">#                 &amp; \textbf{v}^{\textrm{T}}\textbf{s} \leq V_{\textrm{max}}\\</span>
<a name="l00012"></a>00012 <span class="comment">#   \f}</span>
<a name="l00013"></a>00013 <span class="comment">#  Where</span>
<a name="l00014"></a>00014 <span class="comment">#  \f$ \textbf{c} \f$ is the cost vector. Element \f$ c_{i} \f$ is the gain from taking object \f$i\f$.</span>
<a name="l00015"></a>00015 <span class="comment">#  \f$ \textbf{v} \f$ is the volume vector. Element \f$ v_{i} \f$ is the volume consumed when taking object \f$i\f$.</span>
<a name="l00016"></a>00016 <span class="comment">#  \f$ \textbf{s} \f$ is the solution. Each decision variable \f$ s_{i}\f$ is binary, and takes the value 1 if the object \f$i\f$ is selected to be part of the solution and 0 otherwise.</span>
<a name="l00017"></a>00017 <span class="comment">#  \f$ V_{\textrm{max}} \f$ is the maximum volume allowed for a solution. Every valid solution must comply with the restriction \f$ V_{\textrm{max}} \leq \textbf{c}^{\textrm{T}}\textbf{s} \f$. The parameter \f$ \lambda \f$ is a penalization factor, used to penalize all the unfeasible individuals.</span>
<a name="l00018"></a>00018 <span class="comment">#</span>
<a name="l00019"></a>00019 <span class="comment">#  The objective function of the problem has been modified according to the lagrangian relaxation technique. Furthermore, to make the \f$ \lambda \f$ selection parameter easier, the penalty term has been implemented in a non-linear way, that penalizes only the non-feasible.   </span>
<a name="l00020"></a>00020 <span class="comment">#</span>
<a name="l00021"></a>00021 <span class="comment">#  @section KnapsackEvaluation Knapsack: Deriving the BaseEvaluationOperator to implement the knapsack objective function</span>
<a name="l00022"></a>00022 <span class="comment">#  </span>
<a name="l00023"></a>00023 <span class="comment">#  The GeneticAlgorithm framework provides a set of GeneticAlgorithm that can be used to easily implement an evaluation function. The GeneticAlgorithm.BaseEvaluationOperator provides the evaluateIndividual method, that can be overloaded to evaluate every individual in the population. All GeneticAlgorithm EvaluationOperators should contain all the non-genotype parameters required to evaluate an individual internally. The __init__ function should be overloaded to receive the problem instance parameters and save them internally. See tha Knapsack class documentation for detailed information on these metods.</span>
<a name="l00024"></a>00024 <span class="comment">#</span>
<a name="l00025"></a>00025 <span class="comment">#  @subsection KnapsackInit The initialization function</span>
<a name="l00026"></a>00026 <span class="comment">#  This snippet of code describes the initialization function. Original commentaries are included, because they describe the class members and relate them to the ecuation shown above.</span>
<a name="l00027"></a>00027 <span class="comment">#  Notice that the initialization function receives and stores all the instance-related constants as object members. This is the expected behavior of any derived Evaluation Operator.</span>
<a name="l00028"></a>00028 <span class="comment">#  @code</span>
<a name="l00029"></a>00029 <span class="comment">#    def __init__(self, maxVolume=0, objectVolumes=[], volumeLambda=0.0, objectCosts=[], **kwargs):</span>
<a name="l00030"></a>00030 <span class="comment">#        super(Knapsack, self).__init__(**kwargs)</span>
<a name="l00031"></a>00031 <span class="comment">#        ## @member maxVolume The maximum volume allowed for feasible solutions \f$ V_{\textrm{max}} \f$</span>
<a name="l00032"></a>00032 <span class="comment">#        self.maxVolume = maxVolume</span>
<a name="l00033"></a>00033 <span class="comment">#        ## @member objectVolumes The vector of object volumes \f$ \textbf{v} \f$</span>
<a name="l00034"></a>00034 <span class="comment">#        self.objectVolumes = objectVolumes</span>
<a name="l00035"></a>00035 <span class="comment">#        ## @member objectCosts The vector of object costs \f$ \textbf{c} \f$</span>
<a name="l00036"></a>00036 <span class="comment">#        self.objectCosts = objectCosts</span>
<a name="l00037"></a>00037 <span class="comment">#        ## @member volumeLambda The penalization factor \f$ \lambda \f$</span>
<a name="l00038"></a>00038 <span class="comment">#        self.volumeLambda = volumeLambda</span>
<a name="l00039"></a>00039 <span class="comment">## @endcode</span>
<a name="l00040"></a>00040 <span class="comment">#</span>
<a name="l00041"></a>00041 <span class="comment">#  @subsection KnapsackEval The evaluateIndividual function</span>
<a name="l00042"></a>00042 <span class="comment">#</span>
<a name="l00043"></a>00043 <span class="comment">#  The main objective of all derived EvaluationOperators is to implement this function. The GeneticAlgorithm Scheduler calls this function for each newly generated individuals, every iteration. The programmer is responsible for filling in the individual.fitness member with the result of its evaluation, as exemplified below:</span>
<a name="l00044"></a>00044 <span class="comment">#</span>
<a name="l00045"></a>00045 <span class="comment">#  @code</span>
<a name="l00046"></a>00046 <span class="comment">#    def evaluateIndividual(self, individual):</span>
<a name="l00047"></a>00047 <span class="comment">#        # Get the vector s</span>
<a name="l00048"></a>00048 <span class="comment">#        segmentsValues = [segment.data for segment in individual.genotype.segments]</span>
<a name="l00049"></a>00049 <span class="comment">#        # Compute the volume used by the solution</span>
<a name="l00050"></a>00050 <span class="comment">#        usedVolume = reduce(lambda x, y: x+y, map(lambda v, s:v*s, self.objectVolumes, segmentsValues))</span>
<a name="l00051"></a>00051 <span class="comment">#        # Compute the solution cost</span>
<a name="l00052"></a>00052 <span class="comment">#        solutionCost = reduce(lambda x, y: x+y, map(lambda v, s:v*s, self.objectCosts, segmentsValues))</span>
<a name="l00053"></a>00053 <span class="comment">#        # The difference between the maximum allowed volume and the solution volume is the residual volume</span>
<a name="l00054"></a>00054 <span class="comment">#        residualVolume = self.maxVolume - usedVolume</span>
<a name="l00055"></a>00055 <span class="comment">#        # If the residual volume is less than 0, the solution is not penalized. The solution is penalized with a cost of lambda*residualVolume otherwise</span>
<a name="l00056"></a>00056 <span class="comment">#        lambdaPenalty = 0 if residualVolume &gt; 0 else self.volumeLambda*residualVolume</span>
<a name="l00057"></a>00057 <span class="comment">#        # The individual fitness is the penalty plus the objective</span>
<a name="l00058"></a>00058 <span class="comment">#        individual.fitness = solutionCost + lambdaPenalty</span>
<a name="l00059"></a>00059 <span class="comment">#  @endcode</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061  
<a name="l00062"></a>00062 <span class="comment">## @class Knapsack</span>
<a name="l00063"></a>00063 <span class="comment">#  @brief An evaluation operator that computes the relaxed version of the objective function used to solve a knapsack instance.</span>
<a name="l00064"></a>00064 <span class="comment">#</span>
<a name="l00065"></a>00065 <span class="comment">#  This class implements the following evaluation function:</span>
<a name="l00066"></a>00066 <span class="comment">#   \f{eqnarray*}{</span>
<a name="l00067"></a>00067 <span class="comment">#        \max \limits_{\textbf{s}} z =&amp; \textbf{c}^{\textrm{T}}\textbf{s} + f_{\lambda}(\textbf{v}, \textbf{s}) \\</span>
<a name="l00068"></a>00068 <span class="comment">#        f_{\lambda}(\textbf{v}, \textbf{s}) =&amp;</span>
<a name="l00069"></a>00069 <span class="comment">#               \left\{</span>
<a name="l00070"></a>00070 <span class="comment">#                 \begin{array}{rl}</span>
<a name="l00071"></a>00071 <span class="comment">#                   \lambda (V_{\textrm{max}} - \textbf{c}^{\textrm{T}}\textbf{s}) &amp; \textrm{ if }  \textbf{v}^{\textrm{T}}\textbf{s} \leq V_{\textrm{max}}\\</span>
<a name="l00072"></a>00072 <span class="comment">#                   0 &amp;  \textrm{otherwise}</span>
<a name="l00073"></a>00073 <span class="comment">#                 \end{array}</span>
<a name="l00074"></a>00074 <span class="comment">#               \right. \\</span>
<a name="l00075"></a>00075 <span class="comment">#   \f}</span>
<a name="l00076"></a>00076 <span class="comment">#</span>
<a name="l00077"></a>00077 <span class="comment">#  The parameter \f$ \textbf{c} \f$ is the cost vector. Element \f$ c_{i} \f$ is the gain from taking object \f$i\f$.</span>
<a name="l00078"></a>00078 <span class="comment">#  The parameter \f$ \textbf{v} \f$ is the volume vector. Element \f$ v_{i} \f$ is the volume consumed when taking object \f$i\f$.</span>
<a name="l00079"></a>00079 <span class="comment">#  The parameter \f$ \textbf{s} \f$ is the solution. Each decision variable \f$ s_{i}\f$ is binary, and takes the value 1 if the object \f$i\f$ is selected to be part of the solution and 0 otherwise.</span>
<a name="l00080"></a>00080 <span class="comment">#  The parameter \f$ V_{\textrm{max}} \f$ is the maximum volume allowed for a solution. Every valid solution must comply with the restriction \f$ V_{\textrm{max}} \leq \textbf{c}^{\textrm{T}}\textbf{s} \f$. The parameter \f$ \lambda \f$ is a penalization factor, used to penalize all the unfeasible individuals.</span>
<a name="l00081"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html">00081</a> <span class="keyword">class </span><a class="code" href="classKnapsackDemo_1_1Knapsack.html" title="An evaluation operator that computes the relaxed version of the objective function used to solve a kn...">Knapsack</a>(EvaluationOperators.BaseEvaluationOperator):
<a name="l00082"></a>00082     <span class="comment">## @fn __init__(self, maxVolume=0, objectVolumes=[], volumeLambda=0.0, objectCosts=[], **kwargs)</span>
<a name="l00083"></a>00083     <span class="comment">#  @brief Initialize an evaluation operator to implement the evaluation function as described above</span>
<a name="l00084"></a>00084     <span class="comment">#  @param maxVolume The maximum volume allowed for feasible solutions \f$ V_{\textrm{max}} \f$</span>
<a name="l00085"></a>00085     <span class="comment">#  @param objectVolumes The vector of object volumes \f$ \textbf{v} \f$</span>
<a name="l00086"></a>00086     <span class="comment">#  @param objectCosts The vector of object costs \f$ \textbf{c} \f$</span>
<a name="l00087"></a>00087     <span class="comment">#  @param volumeLambda The penalization factor \f$ \lambda \f$</span>
<a name="l00088"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html#a5b91ce58d7f385bd9f883ab145d1125e">00088</a>     <span class="keyword">def </span><a class="code" href="classKnapsackDemo_1_1Knapsack.html#a5b91ce58d7f385bd9f883ab145d1125e" title="Initialize an evaluation operator to implement the evaluation function as described above...">__init__</a>(self, maxVolume=0, objectVolumes=[], volumeLambda=0.0, objectCosts=[], **kwargs):
<a name="l00089"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html#a77e45307df2d47babffcd48dbefaa5f4">00089</a>         super(Knapsack, self).<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a5b91ce58d7f385bd9f883ab145d1125e" title="Initialize an evaluation operator to implement the evaluation function as described above...">__init__</a>(**kwargs)
<a name="l00090"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html#acb231db9c622717c7a1ecdb6d5698211">00090</a>         <span class="comment">## @member maxVolume The maximum volume allowed for feasible solutions \f$ V_{\textrm{max}} \f$</span>
<a name="l00091"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html#a40ab09149cff1a83c1f0ceaabbca4349">00091</a>         self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a77e45307df2d47babffcd48dbefaa5f4" title="maxVolume The maximum volume allowed for feasible solutions ">maxVolume</a> = maxVolume
<a name="l00092"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html#a82c082dcc126c715c87a4349615d03e7">00092</a>         <span class="comment">## @member objectVolumes The vector of object volumes \f$ \textbf{v} \f$</span>
<a name="l00093"></a>00093         self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#acb231db9c622717c7a1ecdb6d5698211" title="objectVolumes The vector of object volumes ">objectVolumes</a> = objectVolumes
<a name="l00094"></a>00094         <span class="comment">## @member objectCosts The vector of object costs \f$ \textbf{c} \f$</span>
<a name="l00095"></a>00095         self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a40ab09149cff1a83c1f0ceaabbca4349" title="objectCosts The vector of object costs ">objectCosts</a> = objectCosts
<a name="l00096"></a>00096         <span class="comment">## @member volumeLambda The penalization factor \f$ \lambda \f$</span>
<a name="l00097"></a>00097         self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a82c082dcc126c715c87a4349615d03e7" title="volumeLambda The penalization factor ">volumeLambda</a> = volumeLambda
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="comment">## @fn evaluateIndividual(self, individual)</span>
<a name="l00100"></a>00100     <span class="comment">#  @brief Evaluate an individual according to the function described above</span>
<a name="l00101"></a>00101     <span class="comment">#  @param individual The list [segment.data for segment in individual.genotype.segments] contains the solution vector \f$ \textbf{s} \f$</span>
<a name="l00102"></a><a class="code" href="classKnapsackDemo_1_1Knapsack.html#ae8ab0e153e9a312df17bfa1eaace97dd">00102</a>     <span class="keyword">def </span><a class="code" href="classKnapsackDemo_1_1Knapsack.html#ae8ab0e153e9a312df17bfa1eaace97dd" title="Evaluate an individual according to the function described above.">evaluateIndividual</a>(self, individual):
<a name="l00103"></a>00103         <span class="comment"># Get the vector s</span>
<a name="l00104"></a>00104         segmentsValues = [segment.data <span class="keywordflow">for</span> segment <span class="keywordflow">in</span> individual.genotype.segments]
<a name="l00105"></a>00105         <span class="comment"># Compute the volume used by the solution</span>
<a name="l00106"></a>00106         usedVolume = reduce(<span class="keyword">lambda</span> x, y: x+y, map(<span class="keyword">lambda</span> v, s:v*s, self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#acb231db9c622717c7a1ecdb6d5698211" title="objectVolumes The vector of object volumes ">objectVolumes</a>, segmentsValues))
<a name="l00107"></a>00107         <span class="comment"># Compute the solution cost</span>
<a name="l00108"></a>00108         solutionCost = reduce(<span class="keyword">lambda</span> x, y: x+y, map(<span class="keyword">lambda</span> v, s:v*s, self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a40ab09149cff1a83c1f0ceaabbca4349" title="objectCosts The vector of object costs ">objectCosts</a>, segmentsValues))
<a name="l00109"></a>00109         <span class="comment"># The difference between the maximum allowed volume and the solution volume is the residual volume</span>
<a name="l00110"></a>00110         residualVolume = self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a77e45307df2d47babffcd48dbefaa5f4" title="maxVolume The maximum volume allowed for feasible solutions ">maxVolume</a> - usedVolume
<a name="l00111"></a>00111         <span class="comment"># If the residual volume is less than 0, the solution is not penalized. The solution is penalized with a cost of lambda*residualVolume otherwise</span>
<a name="l00112"></a>00112         lambdaPenalty = 0 <span class="keywordflow">if</span> residualVolume &gt; 0 <span class="keywordflow">else</span> self.<a class="code" href="classKnapsackDemo_1_1Knapsack.html#a82c082dcc126c715c87a4349615d03e7" title="volumeLambda The penalization factor ">volumeLambda</a>*residualVolume
<a name="l00113"></a>00113         <span class="comment"># The individual fitness is the penalty plus the objective</span>
<a name="l00114"></a>00114         individual.fitness = solutionCost + lambdaPenalty
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">## @page KnapsackPage Solving the Knapsack problem</span>
<a name="l00117"></a>00117 <span class="comment">#  @section KnapsackGA Running a GeneticAlgorithm using the Knapsack EvaluationOperator</span>
<a name="l00118"></a>00118 <span class="comment">#</span>
<a name="l00119"></a>00119 <span class="comment">#  The knapsack evaluation operator is used in conjunction with the rest of the GeneticAlgorithm framework. This section demonstrates how to implement a script to generate a random knapsack instance and solve it.</span>
<a name="l00120"></a>00120 <span class="comment">#</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keywordflow">if</span> __name__==<span class="stringliteral">&#39;__main__&#39;</span>:
<a name="l00123"></a>00123 <span class="comment">## @page KnapsackPage Solving the Knapsack problem</span>
<a name="l00124"></a>00124 <span class="comment">#  @subsection Generating a random instance</span>
<a name="l00125"></a>00125 <span class="comment">#  This section demonstrates how to generate a random Knapsack instance. The python random package is used for this purpose, as demonstrated below:</span>
<a name="l00126"></a>00126 <span class="comment">#</span>
<a name="l00127"></a>00127 <span class="comment">#  @code </span>
<a name="l00128"></a>00128 <span class="comment">#    import random</span>
<a name="l00129"></a>00129 <span class="comment">#    random.seed(0)</span>
<a name="l00130"></a>00130 <span class="comment">#    </span>
<a name="l00131"></a>00131 <span class="comment">#    # Kanpsack instance parameters</span>
<a name="l00132"></a>00132 <span class="comment">#    nObjects =  12</span>
<a name="l00133"></a>00133 <span class="comment">#    </span>
<a name="l00134"></a>00134 <span class="comment">#    objectVolumes = [random.randrange(1, 20) for i in xrange(nObjects)]</span>
<a name="l00135"></a>00135 <span class="comment">#    objectCosts = [random.randrange(10, 20) for i in xrange(nObjects)]</span>
<a name="l00136"></a>00136 <span class="comment">#    maxVolume = reduce(lambda x, y: x+y, objectVolumes) / 2</span>
<a name="l00137"></a>00137 <span class="comment">#    volumeLambda = maxVolume*10</span>
<a name="l00138"></a>00138 <span class="comment">#  @endcode    </span>
<a name="l00139"></a>00139 <span class="comment">#</span>
<a name="l00140"></a>00140 <span class="comment">#  The object volumes and costs are generated randomly, while the maxVolume is kept at half the volume of all objects, to make sure that the instance is non-trivial and not every object fits in the optimal solution. The penalty constant volumeLambda is chosen to be proportional to the maximumVolume; This guarantees that non-feasible individuals have lower evaluations than the feasible individuals. </span>
<a name="l00141"></a>00141 <span class="comment">#</span>
<a name="l00142"></a>00142 <span class="comment">#  @subsection KnapsackConfig Configuring the genetic algoritm</span>
<a name="l00143"></a>00143 <span class="comment">#</span>
<a name="l00144"></a>00144 <span class="comment">#  The Knapsack evaluation function is designed to maximize, so we create a flag that indicates that, and use it to initialize the selection and logging operators.</span>
<a name="l00145"></a>00145 <span class="comment">#  @code </span>
<a name="l00146"></a>00146 <span class="comment">#    maximize = True</span>
<a name="l00147"></a>00147 <span class="comment">#  @endcode</span>
<a name="l00148"></a>00148 <span class="comment">#</span>
<a name="l00149"></a>00149 <span class="comment">#  The number of generations to run, the populationSize and the generationSize are chosen to be proportional to the size of the problem. These numbers are not guaranteed to produce the best result for a particular instance, but have been found experimentally to produce good results when compared to non-probabilistic search algorithms</span>
<a name="l00150"></a>00150 <span class="comment"># </span>
<a name="l00151"></a>00151 <span class="comment">#  @code</span>
<a name="l00152"></a>00152 <span class="comment">#    nGenerations = nObjects*5</span>
<a name="l00153"></a>00153 <span class="comment">#    popSize = nObjects*10</span>
<a name="l00154"></a>00154 <span class="comment">#    genSize = int(math.floor( popSize/10 ))</span>
<a name="l00155"></a>00155 <span class="comment">#  @endcode </span>
<a name="l00156"></a>00156 <span class="comment">#</span>
<a name="l00157"></a>00157 <span class="comment">#  The variable nGenerations will be used to control how many iterations to run using a GAScheduler. The variable popSize will be used during the population construction, and determines how many individuals are contained simultaneously in a population. The variable genSize will be used to initialize the population as well, and controls how many individuals are replaced with each iteration. As a thumbrule, all the parameters that need to be shared between operators, should be a part of the population object. At this point, every required parameter is defined, and we can proceed to initialize GeneticAlgorithm objects.</span>
<a name="l00158"></a>00158 <span class="comment">#</span>
<a name="l00159"></a>00159 <span class="comment">#  First, a prototype chromosome is created. This is used to initialize all the individuals in the population uniformly.</span>
<a name="l00160"></a>00160 <span class="comment">#</span>
<a name="l00161"></a>00161 <span class="comment">#  @code</span>
<a name="l00162"></a>00162 <span class="comment">#    ch = Core.Genotype(segments=[GenotypeLibrary.BinaryChromosomeSegment(nBits=1) for i in range(nObjects)])</span>
<a name="l00163"></a>00163 <span class="comment">#  @endcode</span>
<a name="l00164"></a>00164 <span class="comment">#</span>
<a name="l00165"></a>00165 <span class="comment">#  The main data container on a genetic algorithm is the population object. This contains a list of individuals, and all the parameters that an operator needs to determine how to transform the population, such as mutation probability, crossover probability, the maximization target and how many individuals to replace per iteration (genSize).</span>
<a name="l00166"></a>00166 <span class="comment">#  @code</span>
<a name="l00167"></a>00167 <span class="comment">#    p  = Core.Population(schema=ch, popSize=popSize, genSize=genSize, maximize=maximize, mutation_probability=0.01)</span>
<a name="l00168"></a>00168 <span class="comment">#  @endcode</span>
<a name="l00169"></a>00169 <span class="comment">#</span>
<a name="l00170"></a>00170 <span class="comment">#  The Scheduler object contains a population object, as well as a list of genetic operators that are applied iteratively to the population. Here we instantiate some useful operators:</span>
<a name="l00171"></a>00171 <span class="comment">#  @code</span>
<a name="l00172"></a>00172 <span class="comment">#    ga = Core.Scheduler(name=&#39;Demo&#39;,\</span>
<a name="l00173"></a>00173 <span class="comment">#                        population=p,\</span>
<a name="l00174"></a>00174 <span class="comment">#                        operators=[Knapsack(maxVolume, objectVolumes, volumeLambda, objectCosts),\</span>
<a name="l00175"></a>00175 <span class="comment">#                                   LoggingOperators.LogGenerations(iterationFrequency=1),\</span>
<a name="l00176"></a>00176 <span class="comment">#                                   PlottingOperators.PlotBestLogger(iterationFrequency=1, maximize=maximize),\</span>
<a name="l00177"></a>00177 <span class="comment">#                                   SelectionOperators.KTournament(),\</span>
<a name="l00178"></a>00178 <span class="comment">#                                   SelectionOperators.SelectLethals(),\</span>
<a name="l00179"></a>00179 <span class="comment">#                                   Core.Crossover(),\</span>
<a name="l00180"></a>00180 <span class="comment">#                                   Core.Mutate()])  </span>
<a name="l00181"></a>00181 <span class="comment">#  @endcode</span>
<a name="l00182"></a>00182 <span class="comment">#</span>
<a name="l00183"></a>00183 <span class="comment">#  The evaluartion operator is the first one, because individuals need to be evaluated before logging, selection, crossover or mutation can occur. The first GeneticOperator object in the list is an instance of our Knapsack class; Note that every variable that characterizes an instance is passed to the initialization function of the object, so that it can reference them whenever it is required.</span>
<a name="l00184"></a>00184 <span class="comment">#  The logging operators come next. The LogGenerations operator simply stores a copy of a population and all its individuals every time that an iterationFrequency iterations have elapsed. This example stores every generation of the run.</span>
<a name="l00185"></a>00185 <span class="comment">#  The PlotBestLogger operator is instantiated next. This operator can be instantiated multiple times, and used to keep track of several properties of an individual. This is the reason why the maximization flag has to be passed to this operator. This class samples the fitness member by default every time that an iterationFrequency iterations have elapsed.</span>
<a name="l00186"></a>00186 <span class="comment">#  The traditional genetic operators are instantiated next. The KTournament operator implements a 2-tournament selection scheme by default; It sets the matingPool member of the population object to contain a list of indices, which identify the parent individuals used to produce the iteration offspring. The SelectLethals operator selects the worse genSize individuals and marks them for removal with every iteration. The crossover operator generates new individuals by combining the genotypes of the parents in the mating pool, using a one-point crossover algorithm. Finally, the mutation operator may select a random bit from the new offspring and flip its value, to introduce variability to the population.</span>
<a name="l00187"></a>00187 <span class="comment">#</span>
<a name="l00188"></a>00188 <span class="comment">#  @code</span>
<a name="l00189"></a>00189 <span class="comment">#    ga.runGA(nGenerations)</span>
<a name="l00190"></a>00190 <span class="comment">#  @endcode</span>
<a name="l00191"></a>00191 <span class="comment">#</span>
<a name="l00192"></a>00192 <span class="comment">#  The last block calls the runGA function of the newly created scheduler. This causes the GeneticAlgorithm to run for nGenerations. Every GeneticOperator is an object that supports the basic initialize(), iterate() and finalize() functions. As their name suggests, the Scheduler calls the initialization function of every operator once at the beginning of the run. The iterate function is called nGenerations times, using the genetic operators in a round-robin order. The finalize function of every object is called once after the last iteration, this step is usually implemented by logging operators to print the ga run logged variables to a file or screen.</span>
<a name="l00193"></a>00193     <span class="keyword">import</span> random
<a name="l00194"></a>00194     random.seed(0)
<a name="l00195"></a>00195     
<a name="l00196"></a>00196     <span class="comment"># Kanpsack instance parameters</span>
<a name="l00197"></a><a class="code" href="namespaceKnapsackDemo.html#aa48c8e1a3529bffcb97a3148b868c1c9">00197</a>     nObjects =  12
<a name="l00198"></a>00198     
<a name="l00199"></a><a class="code" href="namespaceKnapsackDemo.html#aeee4d10409c1d6b18aaa563735286a1a">00199</a>     objectVolumes = [random.randrange(1, 20) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(nObjects)]
<a name="l00200"></a><a class="code" href="namespaceKnapsackDemo.html#ac8570f2d747beac2fc32663c22d888ab">00200</a>     objectCosts = [random.randrange(10, 20) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(nObjects)]
<a name="l00201"></a><a class="code" href="namespaceKnapsackDemo.html#a1d13dcf2e502a347e3a1130468a13ade">00201</a>     maxVolume = reduce(<span class="keyword">lambda</span> x, y: x+y, objectVolumes) / 2
<a name="l00202"></a><a class="code" href="namespaceKnapsackDemo.html#ab16eb61d3c00687ba3ec87449dce8dcd">00202</a>     volumeLambda = maxVolume*10
<a name="l00203"></a>00203     
<a name="l00204"></a>00204     <span class="comment"># GA parameters</span>
<a name="l00205"></a><a class="code" href="namespaceKnapsackDemo.html#a76065500a2e315a6db8cf2388b309c18">00205</a>     maximize = <span class="keyword">True</span>
<a name="l00206"></a><a class="code" href="namespaceKnapsackDemo.html#a433c64aeb3151d11c01633130c5d5171">00206</a>     nGenerations = nObjects*5
<a name="l00207"></a><a class="code" href="namespaceKnapsackDemo.html#a0e2d3feb4702ea579e88f1d69c30bedc">00207</a>     popSize = nObjects*10
<a name="l00208"></a><a class="code" href="namespaceKnapsackDemo.html#ae92bf93b2b80f7143e833fa7b27a574c">00208</a>     genSize = int(math.floor( popSize/10 ))
<a name="l00209"></a>00209         
<a name="l00210"></a>00210     <span class="comment"># Genetic algorithm</span>
<a name="l00211"></a><a class="code" href="namespaceKnapsackDemo.html#a419267ffc84d5a1c6b8e59e1518c832e">00211</a>     ch = Core.Genotype(segments=[GenotypeLibrary.BinaryChromosomeSegment(nBits=1) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(nObjects)])
<a name="l00212"></a><a class="code" href="namespaceKnapsackDemo.html#afc7899335ec5c9632ea9af78ec35be82">00212</a>     p  = Core.Population(schema=ch, popSize=popSize, genSize=genSize, maximize=maximize, mutation_probability=0.01)
<a name="l00213"></a><a class="code" href="namespaceKnapsackDemo.html#ad53f5d401ed206657b8e68cd59c90ca9">00213</a>     ga = Core.Scheduler(name=<span class="stringliteral">&#39;Demo&#39;</span>,\
<a name="l00214"></a>00214                         population=p,\
<a name="l00215"></a>00215                         operators=[<a class="code" href="classKnapsackDemo_1_1Knapsack.html" title="An evaluation operator that computes the relaxed version of the objective function used to solve a kn...">Knapsack</a>(maxVolume, objectVolumes, volumeLambda, objectCosts),\
<a name="l00216"></a>00216                                    LoggingOperators.LogGenerations(iterationFrequency=1),\
<a name="l00217"></a>00217                                    PlottingOperators.PlotBestLogger(iterationFrequency=1, maximize=maximize),\
<a name="l00218"></a>00218                                    SelectionOperators.KTournament(),\
<a name="l00219"></a>00219                                    SelectionOperators.SelectLethals(),\
<a name="l00220"></a>00220                                    Core.Crossover(),\
<a name="l00221"></a>00221                                    Core.Mutate()])    
<a name="l00222"></a>00222     ga.runGA(nGenerations)
<a name="l00223"></a>00223     
<a name="l00224"></a>00224     <span class="keywordflow">print</span> <span class="stringliteral">&#39;Object Volumes&#39;</span>, objectVolumes
<a name="l00225"></a>00225     <span class="keywordflow">print</span> <span class="stringliteral">&#39;Object Costs&#39;</span>, objectCosts
<a name="l00226"></a>00226     <span class="keywordflow">print</span> <span class="stringliteral">&#39;Max Volume&#39;</span>, maxVolume
<a name="l00227"></a>00227     <span class="keywordflow">print</span> <span class="stringliteral">&#39;Volume Lambda&#39;</span>, volumeLambda
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="KnapsackDemo_8py.html">KnapsackDemo.py</a>      </li>

    <li class="footer">Generated on Fri Feb 22 2013 21:07:27 for GeneticAlgorithm by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
